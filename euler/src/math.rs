// this module should hold the reusable pieces needed for each problem

// sub modules contain the implementation details for each problem.

// binaries are created in the bin directory for each problem to run, with benchmarking as necessary to compare implementations.

// sum of multiples under N
// n-1 / X rounded down.
//
// example
// under 20 for 5 = (5 + 10 + 15) = 5*(1+2+3) = 5 * 6 = 30
// 20 -1 = 19
// 19/5 = 3.8
// 3.8 rounded = 3
// sum from 1 to 3 has formula (3*(3+1))/2 = 6
// 5 * 6 = 30

pub fn sum_under_n(n: u64) -> u64 {
    return (n * (n + 1)) / 2;
}

pub fn sum_divisible_by(d: u64, limit: u64) -> u64 {
    let p = (limit - 1) / d;
    return d * sum_under_n(p);
}

pub mod one {
    // linear time implementation
    pub fn brute(n: u64) -> u64 {
        let mut sum = 0;
        for i in 1..n {
            // rust ranges exclusive
            if i % 3 == 0 || i % 5 == 0 {
                sum += i
            }
        }
        return sum;
    }

    use super::sum_divisible_by;
    // constant time implementation
    pub fn mathematical(n: u64) -> u64 {
        let three = sum_divisible_by(3, n);
        let five = sum_divisible_by(5, n);
        let fifteen = sum_divisible_by(15, n); // double counted

        // add up individual multiples and remove multiples of 15 one time.
        return three + five - fifteen;
    }
}

static mut N: u32 = 0;

fn fibonacci_recursive(n: u64) -> u64 {
    unsafe {
        N += 1;
    }
    if n == 0 || n == 1 {
        return n;
    }
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2);
}

#[test]
fn test_fib_rec() {
    assert_eq!(0, fibonacci_recursive(0));
    assert_eq!(1, fibonacci_recursive(1));
    assert_eq!(1, fibonacci_recursive(2));
    assert_eq!(2, fibonacci_recursive(3));
    assert_eq!(3, fibonacci_recursive(4));
    assert_eq!(5, fibonacci_recursive(5));
}

fn fibonacci(n: u64) -> u64 {
    return 0;
}

pub mod two {
    /*
    Each new term in the Fibonacci sequence is generated by adding the
    previous two terms. By starting with 1 and 2, the first 10 terms will
    be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    By considering the terms in the Fibonacci sequence whose values do not
    exceed four million, find the sum of the even-valued terms.
    */
    // I see a need for reusable fibonacci coming up...
    //
    // analysis...
    // need the sum of specific terms, specifically the even terms
    // easy to generate individual terms directly by iterating up
    // grows pretty fast, so iteating isn't awful.
    //
    pub fn brute(n: u64) -> u64 {
        use super::fibonacci_recursive;
        use super::N;
        let mut sum = 0;
        for x in 0.. {
            let y = fibonacci_recursive(x);
            println!("x{},y{}", x, y);
            if y > n {
                break;
            }
            if y % 2 == 0 {
                sum += y;
            }
        }
        unsafe {
            println!("N: {}", N);
        }
        return sum;
    }
    // recursive can be cached to speed it up significantly for repeated calls.
    pub fn cached(n: u64) -> u64 {
        let mut sum = 0;
        return sum;
    }

    // a smarter way to do this will include the implementation of fib as it iterates, checking for evenness and limit.
    pub fn mathematical(n: u64) -> u64 {
        return 0;
    }
}

pub mod three {
    /*
    The prime factors of 13195 are 5, 7, 13 and 29.

    What is the largest prime factor of the number 600851475143 ?
     */

    // so now we need to factor numbers.
    // 600_851_475_143 has 12 digits, easily fitting in u64, but too big for u32.
    //
    // we want the largest one, so in theory, we might want to start
    // from the square root of the value and iterate downward
    //
    // ^ this doesn't make any sense.
    //
    // let's do trial division! this takes longer than a minute.
    //
    // Could be easily parallelized.
    //
    // my guess is primes and factors is going to show up a lot...
    //
    pub fn brute(n: u64) -> u64 {
        for i in (2..n - 1).rev() {
            // check if we have a clean division
            if n % i == 0 {
                println!("{} * {} = {}", i, n / i, i * (n / i));
                return i; // we're going from high to low, so first one found is it.
            }
        }
        return 0; // input out of range. maybe panic.
    }

    // if there are a lot of factors, we should start from the bottom,
    // expecting to hit something quickly
    pub fn brute2(mut n: u64) -> Vec<u64> {
        let mut factors = Vec::new();
        for i in 2..n - 1 {
            // check if we have a clean division
            if n % i == 0 { // i is a factor
                factors.push(i);
                println!("{} * {} = {}", i, n / i, i * (n / i));
                n = n / i;
            }
            if n == 1 {
                break;
            }
        }
        return factors; // input out of range. maybe panic.
    }
    // some factors of the number, (not primes!!! just factors)
    //
    // 486847 * 1234169 = 600851475143
    // 71 * 8462696833  = 600851475143
    // square root is useful for determining the upper limit of the
    // things to be used as trials, assuming we start low.

    // when breaking out the factors implemntation, take this as well
    #[test]
    fn test_factors() {
        assert_eq!(vec![5,7,13,29], brute2(13195));
    }
}
