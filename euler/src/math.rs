// this module should hold the reusable pieces needed for each problem

// sub modules contain the implementation details for each problem.

// binaries are created in the bin directory for each problem to run, with benchmarking as necessary to compare implementations.

// sum of multiples under N
// n-1 / X rounded down.
//
// example
// under 20 for 5 = (5 + 10 + 15) = 5*(1+2+3) = 5 * 6 = 30
// 20 -1 = 19
// 19/5 = 3.8
// 3.8 rounded = 3
// sum from 1 to 3 has formula (3*(3+1))/2 = 6
// 5 * 6 = 30

pub fn sum_under_n(n: u64) -> u64 {
    return (n * (n + 1)) / 2;
}

pub fn sum_divisible_by(d: u64, limit: u64) -> u64 {
    let p = (limit - 1) / d;
    return d * sum_under_n(p);
}

pub mod one {
    // linear time implementation
    pub fn brute(n: u64) -> u64 {
        let mut sum = 0;
        for i in 1..n {
            // rust ranges exclusive
            if i % 3 == 0 || i % 5 == 0 {
                sum += i
            }
        }
        return sum;
    }

    use super::sum_divisible_by;
    // constant time implementation
    pub fn mathematical(n: u64) -> u64 {
        let three = sum_divisible_by(3, n);
        let five = sum_divisible_by(5, n);
        let fifteen = sum_divisible_by(15, n); // double counted

        // add up individual multiples and remove multiples of 15 one time.
        return three + five - fifteen;
    }
}

static mut N: u32 = 0;

fn fibonacci_recursive(n: u64) -> u64 {
    unsafe {
        N += 1;
    }
    if n == 0 || n == 1 {
        return n;
    }
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2);
}

#[test]
fn test_fib_rec() {
    assert_eq!(0, fibonacci_recursive(0));
    assert_eq!(1, fibonacci_recursive(1));
    assert_eq!(1, fibonacci_recursive(2));
    assert_eq!(2, fibonacci_recursive(3));
    assert_eq!(3, fibonacci_recursive(4));
    assert_eq!(5, fibonacci_recursive(5));
}

fn fibonacci(n: u64) -> u64 {
    return 0;
}

pub mod two {
    /*
    Each new term in the Fibonacci sequence is generated by adding the
    previous two terms. By starting with 1 and 2, the first 10 terms will
    be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    By considering the terms in the Fibonacci sequence whose values do not
    exceed four million, find the sum of the even-valued terms.
    */
    // I see a need for reusable fibonacci coming up...
    //
    // analysis...
    // need the sum of specific terms, specifically the even terms
    // easy to generate individual terms directly by iterating up
    // grows pretty fast, so iteating isn't awful.
    //
    pub fn brute(n: u64) -> u64 {
        use super::fibonacci_recursive;
        use super::N;
        let mut sum = 0;
        for x in 0.. {
            let y = fibonacci_recursive(x);
            println!("x{},y{}", x, y);
            if y > n {
                break;
            }
            if y % 2 == 0 {
                sum += y;
            }
        }
        unsafe {
            println!("N: {}", N);
        }
        return sum;
    }
    // recursive can be cached to speed it up significantly for repeated calls.
    pub fn cached(n: u64) -> u64 {
        let mut sum = 0;
        return sum;
    }

    // a smarter way to do this will include the implementation of fib as it iterates, checking for evenness and limit.
    pub fn mathematical(n: u64) -> u64 {
        return 0;
    }
}
